'use client'

/**
 * ScooterViewer Component
 * 
 * Displays a 3D scooter model using the <model-viewer> web component.
 * 
 * This component properly handles the async loading of model-viewer script
 * and ensures the custom element is registered before rendering.
 * 
 * IMPORTANT: This component only renders on the client to avoid hydration errors.
 */

import { useEffect, useRef, useState } from 'react'

export default function ScooterViewer({ 
  modelPath, 
  selectedDesign,
  environmentImage = null,
  className = '',
  onRotationChange
}) {
  // All hooks must be called unconditionally and in the same order every render
  const containerRef = useRef(null)
  const modelViewerRef = useRef(null)
  const [scriptLoaded, setScriptLoaded] = useState(false)
  const [isModelLoaded, setIsModelLoaded] = useState(false)
  const [isMounted, setIsMounted] = useState(false)

  // Hook 1: Set mounted state
  useEffect(() => {
    setIsMounted(true)
  }, [])

  // Hook 2: Wait for model-viewer script to load
  useEffect(() => {
    if (!isMounted) return

    // Check if already loaded
    if (typeof window !== 'undefined' && window.customElements) {
      if (window.customElements.get('model-viewer')) {
        setScriptLoaded(true)
        return
      }
    }

    // Poll for script loading
    let checkInterval = setInterval(() => {
      if (typeof window !== 'undefined' && window.customElements) {
        if (window.customElements.get('model-viewer')) {
          setScriptLoaded(true)
          clearInterval(checkInterval)
        }
      }
    }, 50)

    // Timeout after 10 seconds
    const timeout = setTimeout(() => {
      clearInterval(checkInterval)
      console.error('model-viewer script failed to load after 10 seconds')
    }, 10000)

    return () => {
      clearInterval(checkInterval)
      clearTimeout(timeout)
    }
  }, [isMounted])

  // Hook 3: Create and configure model-viewer element
  useEffect(() => {
    if (!isMounted || !scriptLoaded || !containerRef.current || !modelPath) return

    const container = containerRef.current
    
    // Clear any existing content
    container.innerHTML = ''

    // Ensure model path is absolute
    const fullModelPath = modelPath.startsWith('/') ? modelPath : `/${modelPath}`
    console.log('üîç Loading 3D model from:', fullModelPath)

    // Create model-viewer element
    const modelViewer = document.createElement('model-viewer')
    
    // Store interval reference for cleanup
    let cameraCheckInterval = null
    
    // Set src using direct property (more reliable than setAttribute)
    modelViewer.src = fullModelPath
    modelViewer.alt = '3D Scooter Model'
    
    // Basic controls
    modelViewer.setAttribute('camera-controls', '')
    modelViewer.setAttribute('auto-rotate', '')
    modelViewer.setAttribute('rotation-per-second', '30deg')
    modelViewer.setAttribute('interaction-policy', 'allow-when-focused')
    // Enable touch and mouse interaction
    modelViewer.setAttribute('touch-action', 'none')
    // Restrict camera controls to horizontal rotation only
    // This ensures manual rotation follows the same path as auto-rotate
    modelViewer.setAttribute('camera-target', '0m 0m 0m')
    
    // Lighting and rendering
    modelViewer.setAttribute('shadow-intensity', '1')
    modelViewer.setAttribute('exposure', '1.2')
    modelViewer.setAttribute('tone-mapping', 'auto')
    modelViewer.setAttribute('shadow-softness', '0.5')
    
    // Camera settings - restrict rotation to horizontal plane only (Y-axis, like auto-rotate)
    // Format: camera-orbit="theta phi radius"
    // theta: horizontal rotation (0-360deg) - allow full rotation
    // phi: vertical angle (0-180deg) - lock to 75deg (no vertical rotation)
    // radius: distance - allow zoom but restrict range
    modelViewer.setAttribute('camera-orbit', '0deg 75deg 105%')
    modelViewer.setAttribute('field-of-view', '45deg')
    // Lock vertical angle (phi) to exactly 75deg - only allow horizontal rotation (theta)
    // This matches the auto-rotate plane (horizontal rotation only)
    // min/max phi must be the same to prevent vertical rotation
    modelViewer.setAttribute('min-camera-orbit', '0deg 75deg 80%')
    modelViewer.setAttribute('max-camera-orbit', '360deg 75deg 150%')
    // Disable zoom to keep focus on rotation
    // modelViewer.setAttribute('disable-zoom', '') // Uncomment if you want to disable zoom
    
    // Fix orientation for honda-lead model (rotate 90deg around Y-axis to fix "on side" issue)
    // Check if model path contains honda-lead
    if (fullModelPath.includes('honda-lead')) {
      // Rotate model 90 degrees around Y-axis to fix orientation
      // Using CSS transform as model-viewer doesn't have direct orientation attribute
      modelViewer.style.transform = 'rotateY(90deg)'
      console.log('üîÑ Applied orientation fix for honda-lead model (90deg Y-axis rotation)')
    }
    
    // Loading settings
    modelViewer.setAttribute('loading', 'auto')
    modelViewer.setAttribute('reveal', 'auto')
    
    // AR (optional)
    modelViewer.setAttribute('ar', '')
    modelViewer.setAttribute('ar-modes', 'webxr scene-viewer quick-look')
    
    // Set style
    modelViewer.style.width = '100%'
    modelViewer.style.height = '100%'
    modelViewer.style.backgroundColor = '#f5f5f5'
    modelViewer.style.display = 'block'
    modelViewer.style.pointerEvents = 'auto' // Allow interaction with 3D model
    modelViewer.style.touchAction = 'none' // Prevent default touch actions for better rotation

    // Add poster (loading state)
    const poster = document.createElement('div')
    poster.setAttribute('slot', 'poster')
    poster.className = 'absolute inset-0 flex items-center justify-center bg-gradient-to-b from-neutral-100 to-neutral-50'
    poster.innerHTML = `
      <div class="text-center">
        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-neutral-400 mx-auto mb-4"></div>
        <p class="text-neutral-600">Loading 3D Model...</p>
      </div>
    `
    modelViewer.appendChild(poster)

    // Handle model load events
    const handleLoad = (e) => {
      setIsModelLoaded(true)
      console.log('‚úÖ 3D model loaded successfully:', fullModelPath)
    }
    
    const handleModelLoad = (e) => {
      setIsModelLoaded(true)
      console.log('‚úÖ Model-viewer model-loaded event')
    }
    
    const handleProgress = (e) => {
      const progress = e.detail?.totalProgress || 0
      if (progress === 1) {
        console.log('‚úÖ Model loading progress: 100%')
        setIsModelLoaded(true)
      } else {
        console.log(`‚è≥ Model loading progress: ${(progress * 100).toFixed(0)}%`)
      }
    }

    const handleError = (error) => {
      console.error('‚ùå Error loading 3D model:', error)
      console.error('Model path:', fullModelPath)
      setIsModelLoaded(false)
      
      // Show user-friendly error message
      if (container) {
        container.innerHTML = `
          <div class="flex flex-col items-center justify-center h-full bg-gradient-to-b from-neutral-100 to-neutral-50 p-8">
            <div class="text-center">
              <div class="text-6xl mb-4">‚ö†Ô∏è</div>
              <h3 class="text-xl font-semibold text-neutral-900 mb-2">Failed to load 3D model</h3>
              <p class="text-neutral-600 mb-4">Model file: ${fullModelPath}</p>
              <p class="text-sm text-neutral-500 mb-2">Please check:</p>
              <ul class="text-sm text-neutral-500 text-left list-disc list-inside">
                <li>File exists in /public/models/</li>
                <li>File is a valid GLB format</li>
                <li>Browser console for detailed error</li>
              </ul>
            </div>
          </div>
        `
      }
    }

    // Add event listeners
    modelViewer.addEventListener('load', handleLoad)
    modelViewer.addEventListener('model-loaded', handleModelLoad)
    modelViewer.addEventListener('progress', handleProgress)
    modelViewer.addEventListener('error', handleError)

    // Force horizontal-only rotation by intercepting camera changes
    const handleCameraChange = () => {
      try {
        // Get current camera orbit from the element
        // Try multiple methods to get the orbit value
        let currentOrbit = null
        if (modelViewer.getAttribute) {
          currentOrbit = modelViewer.getAttribute('camera-orbit')
        }
        if (!currentOrbit && modelViewer.cameraOrbit) {
          currentOrbit = modelViewer.cameraOrbit.toString()
        }
        if (!currentOrbit && modelViewer.getCameraOrbit) {
          currentOrbit = modelViewer.getCameraOrbit().toString()
        }
        
        if (currentOrbit) {
          // Parse orbit values (format: "theta phi radius")
          const parts = currentOrbit.toString().trim().split(/\s+/)
          if (parts.length >= 2) {
            const theta = parts[0] || '0deg'
            const phi = parts[1] || '75deg'
            const radius = parts[2] || '105%'
            
            // Extract numeric value from phi (e.g., "75deg" -> 75)
            const phiMatch = phi.match(/([\d.]+)/)
            const phiValue = phiMatch ? parseFloat(phiMatch[1]) : 75
            
            // Extract rotation angle (theta) for parallax background
            const thetaMatch = theta.match(/([\d.]+)/)
            const thetaValue = thetaMatch ? parseFloat(thetaMatch[1]) : 0
            if (onRotationChange) {
              onRotationChange(thetaValue)
            }
            
            // Force phi to stay at exactly 75deg (horizontal plane only)
            // Use stricter threshold (0.1deg instead of 0.5deg)
            if (Math.abs(phiValue - 75) > 0.1) {
              const correctedOrbit = `${theta} 75deg ${radius}`
              modelViewer.setAttribute('camera-orbit', correctedOrbit)
              // Also update min/max to ensure they stay locked
              modelViewer.setAttribute('min-camera-orbit', `0deg 75deg 80%`)
              modelViewer.setAttribute('max-camera-orbit', `360deg 75deg 150%`)
            }
          }
        }
      } catch (error) {
        // Silently handle errors
        console.warn('Camera change handler error:', error)
      }
    }

    // Monitor camera changes to enforce horizontal-only rotation
    const startCameraMonitoring = () => {
      if (cameraCheckInterval) return // Already monitoring
      // More frequent checking for better enforcement
      cameraCheckInterval = setInterval(() => {
        handleCameraChange()
      }, 50) // Check every 50ms for more responsive enforcement
    }

    // Start monitoring after model loads
    const handleModelReady = () => {
      setTimeout(() => {
        startCameraMonitoring()
        // Also enforce immediately
        handleCameraChange()
      }, 300) // Wait 300ms for model to initialize
    }
    modelViewer.addEventListener('model-loaded', handleModelReady)
    modelViewer.addEventListener('load', handleModelReady)
    
    // Also listen to camera-change event if available
    if (modelViewer.addEventListener) {
      modelViewer.addEventListener('camera-change', handleCameraChange)
    }
    
    // Enforce on any user interaction
    modelViewer.addEventListener('mousedown', () => {
      setTimeout(handleCameraChange, 10)
    })
    modelViewer.addEventListener('touchstart', () => {
      setTimeout(handleCameraChange, 10)
    })

    // Append to container immediately
    container.appendChild(modelViewer)
    modelViewerRef.current = modelViewer
    console.log('‚úÖ model-viewer element created and appended to DOM')

    // Verify src was set correctly
    setTimeout(() => {
      if (modelViewer.src !== fullModelPath) {
        console.warn('‚ö†Ô∏è Model path mismatch, correcting...')
        modelViewer.src = fullModelPath
      }
    }, 100)

    // Cleanup function
    return () => {
      modelViewer.removeEventListener('load', handleLoad)
      modelViewer.removeEventListener('model-loaded', handleModelLoad)
      modelViewer.removeEventListener('progress', handleProgress)
      modelViewer.removeEventListener('error', handleError)
      if (modelViewer.removeEventListener) {
        modelViewer.removeEventListener('camera-change', handleCameraChange)
      }
      if (cameraCheckInterval) {
        clearInterval(cameraCheckInterval)
        cameraCheckInterval = null
      }
      if (container && container.contains(modelViewer)) {
        container.removeChild(modelViewer)
      }
    }
  }, [isMounted, scriptLoaded, modelPath, environmentImage])

  // Hook 4: Apply design texture/variant when it changes
  useEffect(() => {
    if (!modelViewerRef.current || !selectedDesign || !isModelLoaded) return

    const modelViewer = modelViewerRef.current

    // Method 1: Apply material variant if specified
    if (selectedDesign.variant) {
      try {
        modelViewer.setAttribute('variant-name', selectedDesign.variant)
        console.log('‚úÖ Applied variant:', selectedDesign.variant)
      } catch (error) {
        console.warn('Failed to apply variant:', error)
      }
    }

    // Method 2: Apply texture if specified (requires accessing Three.js scene)
    if (selectedDesign.texture && !selectedDesign.variant) {
      try {
        // Access the model's scene via model-viewer's internal API
        // Note: This is a workaround - model-viewer doesn't officially expose this
        const scene = modelViewer.model || modelViewer.scene
        
        if (scene && typeof window !== 'undefined' && window.THREE) {
          const THREE = window.THREE
          const textureLoader = new THREE.TextureLoader()
          
          console.log('üñºÔ∏è Loading texture:', selectedDesign.texture)
          
          textureLoader.load(
            selectedDesign.texture,
            (texture) => {
              texture.flipY = false
              texture.encoding = THREE.sRGBEncoding
              
              // Traverse scene and apply texture to materials
              scene.traverse((node) => {
                if (node.isMesh && node.material) {
                  const materials = Array.isArray(node.material) ? node.material : [node.material]
                  
                  materials.forEach((material) => {
                    if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                      material.map = texture
                      material.needsUpdate = true
                      console.log('‚úÖ Texture applied to material')
                    }
                  })
                }
              })
              
              // Request render update
              if (modelViewer.requestUpdate) {
                modelViewer.requestUpdate()
              }
            },
            undefined,
            (error) => {
              console.warn('‚ö†Ô∏è Failed to load texture:', error)
            }
          )
        } else {
          console.warn('‚ö†Ô∏è Three.js or scene not available for texture swapping')
          console.log('üí° Tip: Use material variants in your GLB model for better texture switching')
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Texture swap not available:', error)
        console.log('üí° Tip: Export your GLB with material variants for each design')
      }
    }
  }, [selectedDesign, isModelLoaded])

  // NOW all hooks are called - we can do conditional returns
  // Show loading state until mounted or script loaded
  const shouldShowLoading = typeof window === 'undefined' || !isMounted || !scriptLoaded;
  
  if (shouldShowLoading) {
    return (
      <div 
        className={`relative w-full h-full ${className} flex items-center justify-center bg-gradient-to-b from-neutral-100 to-neutral-50`}
        suppressHydrationWarning
        data-loading="true"
      >
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-neutral-400 mx-auto mb-4"></div>
          <p className="text-neutral-600">Loading 3D Viewer...</p>
        </div>
      </div>
    )
  }

  return (
    <div 
      ref={containerRef} 
      className={`relative w-full h-full ${className}`}
      suppressHydrationWarning
      data-client-only="true"
    >
      {/* Environment overlay for soft studio lighting effect */}
      <div 
        className="absolute inset-0 pointer-events-none z-10"
        style={{
          background: 'radial-gradient(ellipse at center, rgba(255,255,255,0.15) 0%, transparent 70%)',
          mixBlendMode: 'overlay',
        }}
        suppressHydrationWarning
      />
    </div>
  )
}
